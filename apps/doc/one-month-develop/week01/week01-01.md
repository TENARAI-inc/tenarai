第 1 週 基礎とコンポーネント

# 基礎項目

## 変数をつかってテキストを表示する

変数を利用してテキストを表示してみよう。  
変数という入れ物に文字列を入力し、その変数の値を画面に出力することができる。  
さらにこの変数の値をあとから書き換えることで、自動的に画面の出力も変更することができる。  
この変数の値と画面が連動していることをリアクティブと呼んだりする。  
vue や react などのライブラリの機能のひとつである。

::: tip
**変数と定数**  
どちらも値の入れ物ではあるが、変数はなんどでも出し入れができる。定数は一度しかいれることができない。  
とどのつまり、定数は変数で代用ができるが定数はメリットがある。  
「絶対に誰も書き換えることができないもの」という存在はバグが発生したときに真っ先に犯人から除外できる。  
基本的に想定外の動きをしているということは、想定外の値が入ったりしているためなのだ。  
変数だらけのソースコードより、定数だらけのソースコードのほうがバグは少ないと思われる。
:::

以下のファイルを追加してみよう

```vue
// apps/tenarai-sample-web/pages/sample.vue

<!-- ここがhtml -->
<template>
  <div>
    <!-- この書き方でtypescriptに宣言された変数titleを出力することができる -->
    <h1>{{ title }}</h1>
  </div>
</template>

<!-- ここがtypescript（ブラウザで実行されるときに自動的にjavascriptに変換される） -->
<script setup lang="ts">
const title = 'Sample Page';
</script>

<!-- ここがcss -->
<style scoped lang="css">
div {
  padding: 40px;
}
</style>
```

以下の url から開くことができる  
[http://localhost:3000/sample](http://localhost:3000/sample)

画面に `Sample Page` と出力されていれば成功だ。

### title 定数

ここでのポイントはこれである。

```js
const title = 'Sample Page';
```

const は定数を宣言しており、 = によって右側の文字列が入力されている。（右辺と左辺が同一という意味ではない）  
const で宣言することにより、プログラムの途中で再代入しようとするとエラーを発生させることができるため、明確な意思で定数にしていることを示すことができる。  
シングルクオート `'` で囲まれている部分が文字列である。  
::: info
文字列はダブルクオート`"`や String クラスで生成することもできるが、とりあえずこのやり方を覚えておけばよいだろう。
:::

### title を変数にする

```js
// 単なるjsの変数
let title = 'Sample Page'; // このtitleは文字列という型

// vueの変数
const title = ref('Sample Page'); // このtitleはオブジェクトという型
```

宣言子 const を let に変えてみると、title は再代入可能な変数だという宣言となる。  
これにより title は何らかのタイミングで別の値が格納されることが明確になった。（そうでない場合定数にすべきだからである）

一方で、vue の場合は const のまま変数にすることができる。  
ややこしいが、これは内部であつかっているアイテムの型と呼ばれる性質に起因する。  
ref という関数（後述）をつかって title 変数を初期化している。その初期化時に渡している値が文字列 `Sample Page` となっているのだ。  
この ref により変数 title は `リアクティブ`な値として画面と連動してふるまうことができる。

今回は vue での動作を前提としているので ref を使った変数を覚えてしまおう。

### ３秒後にページタイトルが変わるようにしよう

以下のコードに変更してみると、ページを表示後 3 秒たってからタイトルがかわるはずだ。  
当然タイトルは `Updated Sample Page Title` である。

```vue{12-16}
// apps/tenarai-sample-web/pages/sample.vue

<!-- ここがhtml -->
<template>
  <div>
    <h1>{{ title }}</h1>
  </div>
</template>

<!-- ここがtypescript（ブラウザで実行されるときに自動的にjavascriptに変換される） -->
<script setup lang="ts">
const title = ref('Sample Page');

setTimeout(() => {
  title.value = 'Updated Sample Page Title';
}, 3000);
</script>

<!-- ここがcss -->
<style scoped lang="css">
div {
  padding: 40px;
}
</style>
```

title は ref をつかってリアクティブになっている。  
ref の変数は `value` というプロパティ（そのアイテムがもつ設定値のこと）をもっており、そこに新しい値を `=` を使って代入することで変数の中身をさしかえることができる。

setTimeout はタイマーの関数であり、3000 という数字の時間が経過したあとに真ん中のコード（`title.value = ***`）が実行されるようになっている。  
これは js が最初からもっている関数（ビルトイン関数と呼ぶ）なので、自分で定義することなくいつでも使うことができる。

3000 はミリ秒という単位である。1 秒が 1000 ミリ秒なので３秒という指定となる。  
結果として画面を開いて３秒後に title 変数に値がセットされ、それを参照している template 内の title 参照箇所（`{`{ title `}`}）が変数の内容をそのまま出力しているということである。

::: tip
逆に言えば template 内で変数を参照しておけば、いつでも画面の文字を変数の中身をかえることで変更させることができるということになる。
:::

## 関数

関数とはなにかの処理をする塊である。  
まず名前を指定して関数を定義し、それを実行することで結果を受け取ることができる。  
これは何度も行うような同じ処理実行に効果を発揮する。  
関数は汎用的につくると再利用しやすくなる。

```js{4-6,15-17}
/**
 * （汎用的ではない）3と4を足した結果を返却する関数
 */
function calculation34() {
  return 3 + 4;
}

// 実行すると常に7がresultに入る
const result = calculation34();

/**
 * （汎用的）２つの数値を足した結果を返却する関数
 * このように関数はパラメータを渡して処理させることが可能
 */
function calculation(a, b) {
  return a + b;
}

// 実行すると加算結果がresultAに入る
const resultA = calculation(1, 99);

// 実行すると加算結果がresultBに入る
const resultB = calculation(49, 1);

// 実行すると150がresultCに入る
const resultC = calculation(resultA, resultB);
```

計算以外にもボタンを押したときに実行される処理を定義する等関数の仕事はかなり多い。  
関数はなにか目的をもっており実行されるとなにか処理を行い、結果を返す関数もあれば実行そのものが目的のものもある。

渡されるパラメータは引数（ひきすう）と呼ばれる。  
引数の名前も自由に決めることができるので読み手が理解しやすい名前をつけるほうがよい。  
これは関数の本体も同様である。

```js
/**
 * これはなにをする関数かなんとなくわかるだろうか
 */
function getFullName(lastName, firstName) {
  return `${lastName} ${firstName} 様`;
}

// "手習 三郎 様"
const fullName = getFullName('手習', '三郎');
```

## 配列

配列とはデータを順番に詰め込む箱である。  
中身は基本的に自由であるが、管理の都合上同じタイプのデータを入れるのが都合がよいのでなるべくそうすべきである。  
たとえば、大部分が靴下をいれてある棚にいきなり猫やひょうたんが入っていると「いったいのその棚は何用なのだろう」ということになる。  
配列も変数に格納するため名前が必要なので、自ずと格納するデータタイプは決まってくるはずである。

```js
/**
 * catsという名前の配列を用意した（長さゼロの配列で初期化した、とも言う）
 * 今回は猫の名前を入れることにするのでひょうたんのデータを入れるのは適切ではない。
 * （猫の名前が'ひょうたん'ならば問題はない）
 * ただ、ひょうたんのデータを入れること自体は可能である。
 */
const cats = [];

// 'にゃんた'という文字列を後ろから追加した
cats.push('にゃんた');

// 'ねこすけ'という文字列を前から追加した
cats.unshift('ねこすけ');

// 'ニャース'という文字列を後ろから追加した
cats.push('ニャース');

/**
 * 現在の cats の中身は以下である
 * catsの配列の長さは3である
 *   catsの0番目のアイテムは 'ねこすけ'である
 *   catsの1番目のアイテムは 'にゃんた'である
 *   catsの2番目のアイテムは 'ニャース'である
 *
 * このように配列の中身は0から数えることになっている
 */
['ねこすけ', 'にゃんた', 'ニャース'];

// catsの0番目のアイテムを変数に格納する
const firstCat = cats[0];
```

- 配列は`[ ]`で表現する。
- 配列にデータがある場合それらを `,` で区切ることで配列の長さが表現される
  - ['ねこすけ', 'にゃんた', 'ニャース'] という配列は３つの`文字列アイテム`が表現されている
- 配列の順番のことをインデックスと呼ぶ。
  - 上記猫配列のインデックス 0 番目のアイテムは `ねこすけ` ということになる。
- 配列にデータを格納する場合配列の持ついくつかの関数を使う
  - push: 現在の配列の最後尾にデータを追加する
  - unshift: 現在の配列の最前列にデータを追加する
  - slice: 対象の配列の目的となるデータだけをぬきとって新しい配列を作成する
    - 猫配列から 1 番目と 2 番目のデータをぬきとると ['にゃんた', 'ニャース'] という配列ができる。

すぐに覚えるのは大変なので、必要なときに調べて使えば良い。

## オブジェクトと json

オブジェクトという一般的すぎる名称は js だと連想配列を指すことが多い。  
この場合文字列等とは別の`情報の塊`を指すが、文字列のことも文字列オブジェクトと呼ぶこともありコンテキストによって変わるので注意が必要だ。
このセクションでのオブジェクトとは連想配列のことである。

### 連想配列（オブジェクト）

連想配列はキーバリュー型とも言われている `なんでも格納ボックス`である。  
通常の配列（上記のセクションの配列）はデータを順番（インデックス）で管理することで n 番目のデータを取り出すことができた。  
連想配列はキーを使って格納し、キー（プロパティ）を使って取り出す。  
順番で管理する必要のない情報はこれが一番直感的でわかりやすく管理ができる。

```js
/**
 * 連想配列で猫を管理する
 */
const nekosuke = { name: 'ねこすけ', age: 3, type: 'マンチカン' };

const nyanta = { name: 'にゃんた', age: 1, type: 'ロシアンブルー' };

const nyaas = { name: 'ニャース', age: 5, type: 'ペルシャ' };

// ねこすけのageプロパティを取り出す
const age = nekosuke.age;
```

なんとなくわかると思うが、上記は三匹の猫の情報オブジェクトを変数に格納している。  
各オブジェクトは name プロパティ、age プロパティ、type プロパティを持っており一つのオブジェクトが一匹の猫の情報を保持している。

これらも配列で管理が可能である。

```js
const cats = [nekosuke, nyanta, nyaas];

上記は以下と同様;
const cats = [
  { name: 'ねこすけ', age: 3, type: 'マンチカン' },
  { name: 'にゃんた', age: 1, type: 'ロシアンブルー' },
  { name: 'ニャース', age: 5, type: 'ペルシャ' },
];

// catsのインデックス2（3番目）のデータを取り出してみる
const thirdCat = cats[2];

// ペルシャ
const type = thirdCat.type;
```

このように、連想配列と配列を組み合わせることで強力な情報管理が可能になる。  
猫の販売サイトがあるとして、そこには猫一覧があるはずだ。  
その一覧は上記のようなデータ構造を使うと表現できることがわかってきただろうか。

### json

json（ジェイソン）は上記のような配列やオブジェクトのデータ構造を文字列で表現するためのフォーマットである。  
単なる文字列なのでテキスト情報ということになるが、構造化された情報というものを簡単に表すことができる優れたフォーマットになっている。  
これは javascript から生まれたために js との親和性が高いが、基本的には `構造化された情報` というもの表現するための手段のひとつである。  
言い換えると`jsonフォーマットを理解できるあらゆるプログラム言語と情報を共有できる` という素晴らしい特性をもつ。

::: tip
構造化された情報 => "三匹の猫の配列情報で、'ねこすけ', 'にゃんた', 'ニャース' の個体情報が含まれている" という概念  
これを表すために、js では上記の [nekosuke, nyanta, nyaas] で表せるが他の言語では他の言語のルールで同様の情報を表現することになる
:::

三匹の猫情報を表すデータを json という文字列で送信し、それを受け取る別プログラムが json を解析して`自前の情報として復元`すればプログラムの言語タイプを問わずに情報を受け渡すことができる。  
これが json を扱う大きな理由でああり、一番利用されるのはサーバへのデータ送信である。  
サーバへ向けて json フォーマットの`文字列`を送信する。これは単なる文字列だが、json としてデータを表現しているためにサーバにあるプログラムは受け取ったあとに json を解析して猫の情報としてデータベースに格納したり既存データを上書きしたりすることができる。  
文字列を扱えて、json を解析できるあらゆる言語のサーバプログラムはこの機能を扱うことができるし多くのプログラムは対応している。  
その他テキスト文字列さえ保存できるなら情報そのものをファイルとして保存することも可能になる。  
これが単なる文字列データである json の強みである。

```js
/**
 * 見た目は猫情報の配列オブジェクトと変わらないが立派なjson文字列である
 */
const catJson = `[
  {
    "name": "ねこすけ",
    "age": 3,
    "type": "マンチカン"
  },
  {
    "name": "にゃんた",
    "age": 1,
    "type": "ロシアンブルー"
  },
  {
    "name": "ニャース",
    "age": 5,
    "type": "ペルシャ"
  }
]`;
```

## 配列とリスト表示

猫配列から画面に猫情報をレンダーしてみよう。
配列には順番に猫情報が入っている。  
なのでこれを順番に取り出して html として書き出してみる。

ul というタグはリストを表示するためのタグである。  
中身は必ず li というタグで表現し、li 一個に一つのアイテムを配置する。  
v-for というのは vue の記法であり、配列からデータを取り出してその数の分だけタグを生成してくれるものである。
今回は猫情報が３つはいった配列を渡したので li が３つ生成される。

```js
/**
 * cats配列をv-forをつかってリスト表示する
 * 二重パーレンで変数をtemplate上に出力することができる。
 * nameとageとtypeプロパティに入っている文字列が結果としてliタグの中に出力される。
 * それが三回分実行されるのだ。
 */
<ul>
  <li v-for="cat in cats" :key="cat.name">
    {{ cat.name }} ({{ cat.age }}歳) - {{ cat.type }}
  </li>
</ul>

// 画面表示
ねこすけ (3歳) - マンチカン
にゃんた (1歳) - ロシアンブルー
ニャース (5歳) - ペルシャ
```

結果としてブラウザにレンダーされる html は以下のようになる。

```html
<ul>
  <li>ねこすけ (3歳) - マンチカン</li>
  <li>にゃんた (1歳) - ロシアンブルー</li>
  <li>ニャース (5歳) - ペルシャ</li>
</ul>
```
