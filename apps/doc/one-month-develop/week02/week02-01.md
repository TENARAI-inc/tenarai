データ取得・送信と型

# データ取得と送信

ページは js を利用してデータを取得したり送信することができる。

tenarai web も画面ロード時にアイテムの配列データを取得して画面にアイテムの一覧を取得している。

## REST api

これは一般によく使われる手法で url の構成からなんのデータが返却されるのかわかりやすい設計となる。

```
REST apiの例

// ユーザー一覧を取得するurl
https://.../api/users

// ユーザー一人（ユーザー番号23262783632のデータ）を取得するurl
https://.../api/users/23262783632

// ユーザー一人のなにかの履歴を取得するurl
https://.../api/users/23262783632/histories

```

## fetch を利用したデータ取得

fetch というメソッドを使うとデータの取得や送信ができる。  
これを利用して REST の endpoint に GET リクエストを送信することでアイテムの情報を取得してみよう。

```js
// resにはユーザー一覧が入る
// （awaitは後述のPromiseをつかったメソッドに対するおまじないのようなもの）
const res = await $fetch('/api/items/');
```

::: info
GET とは後述する http リクエストメソッドと呼ばれるリクエストのタイプを表すもので"情報の取得"を意味する。  
fetch は指定がなければ通常は GET として動作する。
:::

### エラーハンドリング

データのリクエストという行為はいくつかの構成要素で成立する。

```
- 正しい url でリクエストが飛んでいるか
- 正しいリクエストパラメータが付与されているか
- ネットワークに接続できているか
- サーバーは適切に起動しているか
- サーバーは処理の中でエラーを出していないか
- たとえばサーバーは特定の処理結果を、また別のサーバーに依存して取得しているため別サーバの状態の影響をうけていないか
```

これらのどれかが欠損していれば、データの取得は不可能になり、リクエストはエラーとなる。  
つまり結構エラーの可能性は高い。

したがってエラーに対し対応を行なっておく必要がある。  
できるならばエラーのタイプごとにユーザーに分かりやすい説明つきで画面などに出力してあげるのがよい。  
（詳しく書きすぎるのもよくない アタッカーにヒントを与えてしまう）

一般的なエラー説明としては以下のようなものがある。

```
- ネットワークに接続されていません。
- 不正なリクエストです（送信パラメータの不備）
- サーバーが応答しません
- システムエラーが発生しました（サーバーの内部処理のエラー）
```

## http ステータスコード

リクエストに対するレスポンスには `http ステータスコード`と呼ばれる統一されたルールに基づいた状態の番号が付与される。
これはブラウザが受け取るレスポンスヘッダという、個々のリクエストに対して必ず付与されてくる情報エリア内部に書き込まれている。

そのリクエストの結果がどうだったのかを簡単に表すものとして定義されている。  
https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Status

```
正常のときは 200 番代
ウェブ側のエラーは 400 番台
サーバー側のエラーは 500 番台
```

ととりあえず覚えておけばよい。

## http リクエストメソッド

リクエストを行う場合、それがどのようなタイプのものかを指定する必要がある。  
たとえば、情報の取得を目的とするのか、情報の更新を目的とするのか、情報の削除を目的とするのか等である。

前述の REST api をコールする場合この文脈により結果がかなり変わることになる。

- https://.../api/users/23262783632 に対して `GET` する
  - 対象のユーザが返却される
- https://.../api/users/23262783632 に対して `PUT` する
  - 対象のユーザの情報が更新される（名前の変更等）
- https://.../api/users/23262783632 に対して `DELETE` する
  - 対象のユーザの情報が削除される

これらはリクエストの意図を指し示すものであり、実際の処理内容はサービスにより異なる場合がある。  
単にリクエストしただけでは実際のデータ、データベースのレコード等が勝手に削除されるということはない。（自前でその処理を実装する必要がある）

代表的な HTTP リクエストメソッド。

```
- GET
- POST
- PUT
- DELETE
```

これら以外にもある。  
https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Methods

実際にデータの削除や更新をする処理をバックエンドで実装することになった場合を想像してみてほしい。  
もしこれらのメソッドなしで https://.../api/users/23262783632 にリクエストがきた場合、あなたのバックエンドはどのような処理をすべきなのか判断できるだろうか？

ということで、リクエストメソッドは開発者、利用者すべてにおいてそのリクエストの意図を指し示す重要な指針となっている。

::: info
これは一般的な話なので、当然サービスによっては「事情によりうちはすべてのリクエストは POST でコールする設計にしている」などといったことは考えられる。
:::

## 同期処理と非同期処理

api へのリクエストのような、処理の発生から完了までどのくらいかかるのか不明な処理は非同期な処理で扱う。  
（ネットワークの状態やデータベースへのアクセス時間等状況に応じて処理時間に変化がある）

::: info
画面の処理がその長めのリクエストと同期して処理が終わるまで次の処理をしないことを`同期処理`。  
裏側で処理を続けてはいるが画面の動作をブロックしないことを`非同期処理`と呼ぶ。
:::

たとえばリクエストが 30 秒かかったとする。  
その間に完全に画面が硬直してしまうのと、ローディングが出現してアニメーション付きで「お待ちください」とでるのはユーザー体験がまるで違う。  
非同期ならばローディングの出現は可能になる。

ページがロードされたあとの、ユーザーアクション起因のリクエスト処理は基本的に非同期処理として処理する。

## プロミスの活用

その方法としてプロミスという魔法があり、これを生成し `await 処理`を宣言することで非同期処理を js に伝えることが可能になる。

```js
// プロミスにawaitを付与してコールすることで、次の行まで処理を待つことができる
const res = await $fetch('/api/items/');

// プロミスをawaitで待ったために、この次の処理では結果にアクセスできる
if (res.ok) {
  // 結果をもとに成功処理を行う
}

/**
 * awaitで待たない場合jsはリクエストの結果を待たずに
 * 次のコードを処理しようとしてしまうため
 * コールバックチェインといったより複雑なコードが必要になる
 *
 * このプロミスの処理はかなり複雑なため
 * 基本的に "プロミスを返却する関数は、awaitで待つべきである" と覚えておくとよい。
 */

// プロミス使わない場合のサンプル
// 返却値の処理はthenというコールバック関数内部で行う
$fetch('/api/items/')
  // jsonをjsオブジェクトに変換
  .then((response) => response.json())
  .then((res) => {
    // データ取得
    if(res.ok){
      ...
    }
  })
  .catch((e) => {
    // エラー処理
  });
```

プロミスはさまざまな処理の中で入り込んでいるのでゆっくりでよいので概念は理解していきたい。

### プロミスの例

```js
// プロミスを返す関数
function somePromiseFunc() {
  return new Promise();
}

// プロミスを返す関数なのでawaitを使って返却値を受け取る
const response1 = await somePromiseFunc();

// プロミスでの処理のため、一個目のisLoadingと二個目のisLoadingの間には
// 10秒くらいの間があく可能性がある
isLoading.value = true;
const res = await $fetch(`/api/items/${id}`); // この間10秒
isLoading.value = false; // 10秒後に実行
```

### 非プロミスの例

```js
// プロミスではないなにかを返す関数
function someFunc() {
  return 'ora!';
}

// プロミスを返す関数ではないので即座に返却値を参照できる
const response2 = someFunc();

// プロミスでの処理ではないので即座に処理される
isLoading.value = true;
const res = someFunc(); // 数ミリ秒
isLoading.value = false; // 数ミリ秒後に実行、ローディングの意味なし
```
