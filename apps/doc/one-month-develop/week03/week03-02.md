unit テストと integration テスト

# integration テスト

integration（インテグレーション）テストは`統合テスト`と呼ばれている。  
様々なパーツが統合・結合された対象、ここでは web アプリケーションそのものを実際に起動してから行うテストのことを指す。

## テストの種類

- unit テスト（共通関数のテスト）
- component テスト（今回は扱わない）
- integration テスト（アプリケーションのふるまいのテスト）

すでに説明した共通関数のテストは関数単体ごとのテストである。  
それ以外に component テストというものもあるが、時間の関係で今回は割愛する。  
component テストはその名のとおり component 単体が適切に動作しているのかをテストするものであり、あるとうれしいが `integration テストほどではない`。

## integration テスト概要

integration テストはコードをビルドして（もしくは開発モードでも問題ない）実際のアプリケーションとして動作させるため、より本番に違い検証を行うことができる。  
パーツ単体をテストして動作を確認できていたとしても、それらを結合してアプリとして動かしてみたら意図通り動かなかったなどという可能性は割とある。  
リリース前のテストとして integratoin テストと component テストのどちらを優先すべきだろうか。

よりユーザ体験に近いアプリに対するテストを終えておけば、本番でまったく動かないアプリがリリースされることは避けることができる。  
明らかに integration テストのほうがメリットやコストパフォーマンスに優れている。

:::info
余裕がある、もしくはテストケースによって component テストのほうがメリットが大きい場合にそちらも検討すべきだが、integrateion テストを追加するかどうかで悩む必要はない。  
絶対に必要だからだ。
:::

## integration テストでの api

基本的に integration テストではあらゆるケースをカバーする必要がある。  
アプリがふるまいを変えたりするのはユーザのアクションや api からのレスポンスによることが多い。  
integration テストのためのツールはボタンのクリック等をやってくれるためユーザのアクションを伴うチェックは可能である。  
つまり api のレスポンスを操れればほぼすべてのケースをカバーできる。

### api モック

api のレスポンスを意図的に変更することをモック化という。  
アプリケーションがリクエストを発生させたあと、実際のサーバにリクエストを届けるのではなくそれをインターセプトして思い通りのレスポンスを返すことで想定されるすべてのパターンのアプリケーションのふるまいをテストすることができる。  
これが integration テストの一番のメリットといえる。  
このときのアプリケーションのふるまいは、ユーザが実際に体験するものと同一である。  
アプリケーションが受け取るパターンを api モックにより再現することで、実際にアプリがどのようにふるまうのか確認できる。

- このレスポンスがきたらダイアログがでるべき
- このエラーがきたらスナックバーがでるはず
- このタイプのユーザはここのボタンはデアクティブとなる

### ユーザアクションのチェック

それ以外にもユーザ起因のアクションに対応したアプリケーションの振る舞いもチェックできる。

- ユーザがこのボタンを押すとページが変わる
- ユーザが送信ボタンをおすとローディングがでる
- ユーザの入力値がこれだと、フォームにエラー文言がでる

### デグレードの検知

できるだけ多くのテストパターンを追加しておくことで将来大きなメリットが受け取れる。
こうしておけば新規機能の開発の途中でうっかり変更してしまったコードが意図しない場所で特定の機能を破壊してしまったとしても気づくことができる。

```
たとえばなにかしらのユーザスコアを扱うサイトで、
100 点満点のユーザに対して特殊な演出を行う仕様があるとする。
変更により誰も気づかずにその演出が出現しなくなってしまった。
100 点満点はレアなケースなためなかなか本番では出現しなかったが
 3 ヶ月後に 100 点ユーザが出現したにもかかわらず演出が行われないことがわかった。
原因は 3 ヶ月前のちょっとしたリリースのせいだった。
このバグは3 ヶ月間誰も気づくことはなかった。
```

このように頻度の低い実行されることがまれなコードはデグレードされてしまっている（つまりバグにより破壊されている）ことに気づくのが遅かったりする。  
サービスによっては致命的な場合もある。

バグそのものの発生は防ぎようがないが、それがいつどこで仕込まれたのかを素早く知ることはできる。  
そう、テストを行えば良いのだ。  
つまり、integraionte テストにより 100 点満点演出のケースがカバーされていれば、そもそもリリースする前にデグレードに気づくことができる。  
この差は大きい。

### 大規模リファクタリングでのメリット

integration テストを適切に追加しておくことで得られるさらに見逃せない点はリファクタリングに対するものである。  
integration テストはアプリケーションのふるまいをテストするため、よりユーザに近い実行が望ましい。  
具体的には html のコードをキーにしてボタンを取得してクリックをするのではなく、ボタンにレンダーされたラベルをみてボタンをクリックするといった具合である。  
ユーザは html の中身など知らない。

ブラウザにレンダリングされている情報をもとにアプリを操作することで、中身のコードの変更に左右されずにテストを行うことになる。  
さて質問

```
- ある日このアプリケーションの中身がまるっと入れ替わったとする。
- いままで Nuxt と vue で動いてたものが Next と React に変更になった。
- もちろんコードベースはまるっと変わってしまっているが、アプリのふるまい自体に変更はない。
```

このような状況が発生した場合、integration テストはどうするべきだろうか？  
答えは`なにもする必要がない`である。

### コード変更に対するバグの防波堤としてのテスト

integration がしっかりレンダーアイテムを利用したテストを行っているかぎり、integration テスト、つまりユーザ側からしたらなんの変更もない。  
ボタンの配置も、ラベルも、ページのタイトルやクリック後の動きもすべて同様なわけだからユーザからするとまったく同一のアプリケーションになっている。

:::info
ふるまいをチェックしている integratoin テストからしても期待値は以前とかわらず同一なのだからテストコードを変える必要がない。  
たとえ中身のコードがまるっきり変わっていてもユーザからすると関係はない。
:::

これが意味することは、コードが変わってアプリケーションのふるまいが変わってしまった場合`それにすぐさま気づける`ということになる。  
この例のように、フレームワークそのものを変えるような大規模なコード変更や改善（リファクタリングと呼ばれる）をした場合どこかしらバグにより以前と同様のふるまいが破壊されることが多い。  
integration テストはそれらすべてを検知して開発者に教えてくれる。  
逆に integration テストがパスしているのであれば、`テストがカバーしているエリアはすべて問題なく動作していることが保証できる`。  
このチェック機構があればこそ、リファクタリングが可能になる。  
アプリケーションが破壊されていないことを確認しながらコード変更が可能だからだ。

あるサービスが大規模リファクタリングをしたとして、以前動いていた機能がまるっきり変わっていたりバグだらけだったとしたらユーザはすぐに離れてしまう。  
サービスの品質を保持するためにも必要不可欠なものが integration テストである。

:::info
いくら integration テストがあったとしてもテストケースがカバーしていないケースはデグレードに気付けない。  
上記の恩恵を受け取るためにはなるべくすべてのケースをカバーしていることが前提となる。  
たとえばいくらレアだからといって 100 点満点演出のテストケースを追加するのをサボると何が起こるのか理解できるだろう
:::

### コストパフォーマンス

テストを変更しなくてよい、というのはそれだけでメリットがある。  
内部コードが変わるときにテストコードもすべて変える必要がある場合かなりのコストだし、そもそもアプリケーションの非破壊チェックの前提が崩れてしまう。  
変更したテストが正しいのかわからないのだから。

共通関数も機能だけを提供しているため、フレームワーク変更の影響を受けない。  
その点でパフォーマンスはよいと言える。

component テストはテストの書き方によるが、もしフレームワークありきのテストコードになっている場合すべて変更する必要がでてくる。  
この点からも優先度は低めとなる。
