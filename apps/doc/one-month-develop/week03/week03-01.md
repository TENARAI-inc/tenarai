unit テストと integration テスト

# unit テスト

unit テストというものは人によって定義が変わるが、ここで言うのは共通関数のテストのことである。

テスト追加のメリットは大きい。

- テストがあると、デグレード（機能破壊）が起きていないかのチェックになる。
- ニッチなケースのパターンも動作の確認がとれる。
- どこがバグを起こしているのか、テストをパスしている場合調査対象から除外できる。

共通関数は基本的に依存がなく入力と出力が対になっていてテストを書きやすいのでどんどん追加するべき。

## 共通関数へのテスト追加

実際にテストを書いてみる.  
以下は vitest を利用したテストコードとなる。（他にも jest が有名だが、書き方はほぼ同様）

```js
/**
 * 基本的に値段を返却し
 * 値段がゼロの場合 無料 を返却する関数
 */
const dispPrice = (price: number): string => {
  if (price === 0) return '無料';
  return `${price.toLocaleString()}円`;
};

// 以下テストファイル

import { describe, it, expect } from 'vitest';
import { dispPrice } from '../util'; // dispPriceをインポートする

describe('dispPrice', () => {
  /**
   * テストケース一個目
   */
  it('return price with JP format', () => {
    expect(dispPrice(1000)).toBe('1,000円');
  });
  /**
   * テストケース二個目
   */
  it('return 無料 with zero value', () => {
    expect(dispPrice(0)).toBe('無料');
  });
});
```

このように describe で箱をつくり、テストケースを個別に it 関数でテストを定義する。（test 関数というものも使えるが、機能に差はない）  
expect 関数に期待値を書き込み、`この関数はこの場合このような値を返却するはずである` というテストを好きなだけ列挙していく。

### どのように破壊がおきるのか

一度作成した共通関数は自分がつくったものなのだから変な変更はしないと考えている人もいるかもしれない。  
だがアプリケーションが大規模になったり、要件に変更があったり、もしくは自分以外の人が手を加える場合はどうだろうか。

```js
// 特定の画面では 無料 ではなくタダと表記することになったので、
// 新人が深く考えることなく共通関数に修正を加えた
const dispPrice = (price: number): string => {
  if (price === 0) return '無料'; // [!code --]
  if (price === 0) return 'タダ'; // [!code ++]
  return `${price.toLocaleString()}円`;
};
```

これにより状況によって 無料 とでているすべての画面に影響を与えた。

```
この変更は誰も気づくことなくしかもdispPriceにゼロが渡されるまで
見えないのでバグとして発見されたのは2ヶ月後だった
```

という可能性もある。

## なぜテストを追加すべきなのか

テストがない場合こっそりと行われた変更に気づくのは難しい。  
コードレビューというフローもあるがそれはレビュアーの力量に依存する。

たとえば自分がどこかのタイミングである処理に変更を加えたあと

```
「この関数ってどこから使われていたっけ」
「ちょっと変えたけど他に影響あるだろうか」
「きっと大丈夫だろう」
```

と考えている未来は十分考えられる。  
変更するのであれば使用しているすべての箇所のチェックが必要だ（100 箇所あれば 100 箇所のチェックとなる）。

その時に既存の動作にデグレードが発生していないかチェックしてくれるのがテストというものなのだ。  
関数を変更したあと、テストがパスされれば `既存の動作に影響はない` と言えるし、変更が意図したもので期待どおりテストが壊れていればそれを修正すればよい。

結局は開発者を救うために存在していくれている素晴らしい機能だと言える。  
未来の自分を救うために、できるだけ多くのケースに対するテストを追加しておくことが肝要となる。
